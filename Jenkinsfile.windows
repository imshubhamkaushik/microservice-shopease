pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = "docker.io"
        DOCKER_ORG = "imshubhamkaushik" // your dockerhub username
        
        IMAGE_TAG = "${BUILD_NUMBER}" // You can customize the image tag as per your requirement
        
        USER_SERVICE_IMAGE = "${DOCKER_ORG}/user-service:${IMAGE_TAG}"
        PRODUCT_SERVICE_IMAGE = "${DOCKER_ORG}/product-service:${IMAGE_TAG}"
        FRONTEND_SERVICE_IMAGE = "${DOCKER_ORG}/frontend-service:${IMAGE_TAG}"
        
        HELM_CHART_DIR = "helm/shopease-hc" // Directory for Helm chart, can use different directory
        
        SONARQUBE = "sonarqube" // Jenkins credential ID for SonarQube, can use different Id as per your choice
        DOCKER_CREDENTIALS = "dockerhub" // Jenkins credential ID for dockerhub, can use different Id as per your choice
        
        /* 
         * CLUSTER_TYPE:
         *  - minikube : local,ephemeral cluster (default for thi project)
         *  - cloud    : cloud provider managed cluster (EKS, GKE, AKS, etc)
         */
        CLUSTER_TYPE = "minikube"
        
        KUBERNETES_CREDENTIALS = "kubernetes-config" // Used ONLY for cloud clusters - Jenkins credential ID for kubernetes, can use different Id as per your choice
        DB_PASSWORD_CREDENTIAL_ID = "shopease-db-password" // Jenkins credential ID for DB password, can use different Id as per your choice
        K8S_NAMESPACE = "default"

    }

    stages {

        // Unit and Integration Tests for Backend Services (parallel execution)
        stage('Unit and Integration Tests for Backend Services') {
            parallel {
                stage('User Service Tests + Coverage') {
                    steps {
                        dir('user-service') {
                            bat 'mvn -B clean verify'
                        }
                    }
                }

                stage('Product Service Tests + Coverage') {
                    steps {
                        dir('product-service') {
                            bat 'mvn -B clean verify'
                        }
                    }
                }
            }
        }

        // Backend Build, SonarQube Analysis, and Quality Gate
        stage('Build Services (Parallel)') {
            parallel {

                // Build and SonarQube for User Service
                stage('User Service - Build and SonarQube') {
                    steps {
                        dir('user-service') {
                            bat 'mvn -B -DskipTests clean package'
                            withSonarQubeEnv("$SONARQUBE") {
                                bat 'mvn sonar:sonar'
                            }
                        }

                        timeout(time: 5, unit: 'MINUTES') {
                            waitForQualityGate abortPipeline: true
                        }
                    }
                }

                // Build and SonarQube for Product Service
                stage('Product Service - Build and SonarQube') {
                    steps {
                        dir('product-service') {
                            bat 'mvn -B -DskipTests clean package'
                            withSonarQubeEnv("$SONARQUBE") {
                                bat 'mvn sonar:sonar'
                            }
                        }

                        timeout(time: 5, unit: 'MINUTES') {
                            waitForQualityGate abortPipeline: true
                        }
                    }
                }

                // Frontend Service Build
                stage('Frontend Service - Build') {
                    steps {
                        dir('frontend') {
                            bat 'npm install'
                            bat 'npm run build'
                        }
                    }
                }
            }
        }

        // Docker Image Build for All Services
        stage ('Build Docker Images for All Services (Parallel)') {
            parallel {
                stage('Build "User Service" Docker Image') {
                    steps {
                        bat "docker build -t ${USER_SERVICE_IMAGE} ./user-service"
                    }
                }

                stage('Build "Product Service" Docker Image') {
                    steps {
                        bat "docker build -t ${PRODUCT_SERVICE_IMAGE} ./product-service"
                    }
                }

                stage('Build "Frontend Service" Docker Image') {
                    steps {
                        bat "docker build -t ${FRONTEND_SERVICE_IMAGE} ./frontend"
                    }
                }
            }
        }
        
        // Trivy Scan Docker Images
        stage('Trivy Scan Docker Images') {
            parallel {
                stage('Scan "user-service" Image') {
                    steps {
                        bat "trivy image --severity HIGH,CRITICAL --exit-code 1 --ignore-unfixed ${USER_SERVICE_IMAGE}"
                    }
                }

                stage('Scan "product-service" Image') {
                    steps {
                        bat "trivy image --severity HIGH,CRITICAL --exit-code 1 --ignore-unfixed ${PRODUCT_SERVICE_IMAGE}"
                    }
                }

                stage('Scan "frontend-service" Image') {
                    steps {
                        bat "trivy image --severity HIGH,CRITICAL --exit-code 1 --ignore-unfixed ${FRONTEND_SERVICE_IMAGE}"
                    }
                }
            }
        }
        
        // Docker Login
        stage('Docker Login') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: "${DOCKER_CREDENTIALS}", 
                    usernameVariable: 'DOCKER_USERNAME', 
                    passwordVariable: 'DOCKER_PASSWORD'
                )]) {
                    bat "echo %DOCKER_PASSWORD% | docker login -u %DOCKER_USERNAME% --password-stdin"
                }
            }
        }

        // Push Docker Images to Registry (Parallel Execution)
        stage ('Push Docker Images (Parallel)') {
            parallel {
                stage ("User Service Image") {
                    steps {
                        bat "docker push ${USER_SERVICE_IMAGE}"
                    }
                }
                stage ("Product Service Image") {
                    steps {
                        bat "docker push ${PRODUCT_SERVICE_IMAGE}"
                    }
                }
                stage ("Frontend Service Image") {
                    steps {
                        bat "docker push ${FRONTEND_SERVICE_IMAGE}"
                    }
                }
            }
        }
        /*
        * WINDOWS + JENKINS + MINIKUBE NOTE
        *
        * Jenkins runs as a Windows service and uses its own user profile.
        * Kubernetes access requires a kubeconfig at:
        *   %USERPROFILE%\.kube\config
        *
        * If this stage fails with:
        *   "Please enter Username: error: EOF"
        *
        * Ensure kubeconfig exists for the Jenkins service account, e.g.:
        *   C:\Windows\System32\config\systemprofile\.kube\config
        */

        // Kubernetes Cluster Preparation
        stage('Prepare Kubernetes Cluster') {
            steps {
                script {
                    if (CLUSTER_TYPE == "minikube") {
                        /* MINIKUBE MODE - WITH BOUNDED WAIT
                         * - Local, ephemeral cluster
                         * - API server port changes on restart
                         * - kubeconfig must be refreshed at runtime
                         * - Jenkins does NOT start Minikube.
                         * - It waits for Minikube to become available (up to a max timeout),
                         * - refreshes kubeconfig, and validates Kubernetes API access.
                         */
                        bat '''
                        echo =========================================
                        echo Preparing Minikube Cluster (consume-only)
                        echo =========================================
                        
                        REM Force Jenkins to use the same kubeconfig as interactive user
                        set KUBECONFIG=%USERPROFILE%\\.kube\\config

                        set MAX_WAIT_SECONDS=300
                        set WAIT_INTERVAL=30
                        set ELAPSED=0

                        :wait_loop
                        minikube status >nul 2>&1
                        IF %ERRORLEVEL% EQU 0 (
                            echo Minikube is running.
                            goto cluster_ready
                        )

                        IF %ELAPSED% GEQ %MAX_WAIT_SECONDS% (
                            echo ERROR: Minikube did not become ready within %MAX_WAIT_SECONDS% seconds.
                            echo Please start Minikube manually and re-run the pipeline.
                            exit /b 1
                        )

                        echo Minikube is not running yet. Waiting %WAIT_INTERVAL% seconds...
                        timeout /t %WAIT_INTERVAL% /nobreak >nul
                        set /a ELAPSED=%ELAPSED%+%WAIT_INTERVAL%
                        goto wait_loop

                        :cluster_ready
                        echo Refreshing kubeconfig and validating cluster...

                        REM Fix API server IP/port drift if Docker restarted
                        minikube update-context

                        REM Explicitly select Minikube context
                        kubectl config use-context minikube

                        REM Hard validation: Kubernetes API must respond
                        kubectl get nodes
                        '''
                    } else {
                        /* CLOUD CLUSTER MODE (EKS / GKE / AKS)
                         * - Long-lived managed cluster
                         * - kubeconfig stored as Jenkins secret/credential
                        */
                        withKubeConfig(credentialsId: "${KUBERNETES_CREDENTIALS}") {
                            bat '''
                            echo "Using Cloud Kubernetes Cluster."
                            kubectl config current-context
                            kubectl get nodes
                            '''
                        }
                    }
                }
            }
        }

        // Verify Monitoring Stack
        stage('Verify Monitoring Stack') {
            steps {
                bat '''
                echo =========================================
                echo Verifying Monitoring Stack
                echo =========================================

                kubectl get ns monitoring >nul 2>&1
                IF %ERRORLEVEL% NEQ 0 (
                    echo INFO: Monitoring namespace not found.
                    echo INFO: Monitoring is expected to be deployed separately.
                    exit /b 0
                )

                echo Monitoring namespace found. Checking core components...
                kubectl -n monitoring get pods
                '''
            }
        }

        //Create K8s secret from Jenkins credential
        stage('Create/Update K8s Secret for DB Password') {
            steps {
                withCredentials([
                    string(credentialsId: "${DB_PASSWORD_CREDENTIAL_ID}", variable: 'DB_PASSWORD')
                ]) {
                    // Use kubectl to create/update secret in the specified namespace
                    bat '''
                    kubectl create secret generic shopease-secrets \
                        --from-literal=DB_PASSWORD=%DB_PASSWORD% \
                        --from-literal=DB_USER=postgres \
                        --dry-run=client -o yaml | kubectl apply -f -
                    '''
                }
            }
        }

        // Trivy Scan Helm Manifests
        stage('Trivy Scan Helm Manifests') {
            steps {
                // Scan Helm templates for misconfigurations
                bat "trivy config --severity HIGH,CRITICAL --exit-code 1 --format table ${HELM_CHART_DIR}"
            }
        }
        
        // Deploy to Kubernetes Using Helm
        stage('Deploy to Kubernetes Using Helm') {
            steps {
                bat "helm upgrade --install shopease ${HELM_CHART_DIR} --namespace ${K8S_NAMESPACE} --create-namespace"
            }
        }

        // Post-Deploy Observability Info
        stage('Post-Deploy Observability Info') {
            steps {
                bat '''
                echo =========================================
                echo Observability Context (Post-Deploy)
                echo =========================================

                kubectl get svc -n monitoring
                '''
            }
        }
    }

    // Post Actions
    post {
        success { echo 'Pipeline Successful!!!' }
        failure { echo 'Pipeline Failed!!! Check Jenkins logs!!!' }
    }
}
